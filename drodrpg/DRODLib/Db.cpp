// $Id: Db.cpp 10108 2012-04-22 04:54:24Z mrimer $

/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Deadly Rooms of Death.
 *
 * The Initial Developer of the Original Code is
 * Caravel Software.
 * Portions created by the Initial Developer are Copyright (C) 1995, 1996, 
 * 1997, 2000, 2001, 2002, 2005 Caravel Software. All Rights Reserved.
 *
 * Contributor(s):
 * Mike Rimer (mrimer)
 *
 * ***** END LICENSE BLOCK ***** */

//Db.cpp
//Implementation of CDb.

#define INCLUDED_FROM_DB_CPP
#include "Db.h"
#undef INCLUDED_FROM_DB_CPP
#include "DbXML.h"
#include "CurrentGame.h"
#include "MonsterFactory.h"
#include "NetInterface.h"
#include "Swordsman.h"

#include <map>
using std::map;

//Holds the only instance of CDb for the app.
CDb *g_pTheDB = NULL;

//Reset hold and player.
UINT CDb::dwCurrentHoldID = 0L;
UINT CDb::dwCurrentPlayerID = 0L;
bool CDb::bFreezeTimeStamps = false;

//
//CDb public methods.
//

//*****************************************************************************
CDb::CDb()
{
	this->Players.FilterByLocal();
}

//*****************************************************************************
CDb::~CDb()
{
	//There shouldn't be any unused rows remaining at this point.
	ASSERT(!EmptyRowsExist());
}

//*****************************************************************************
void CDb::Commit()
//Commits changes in all the databases.
//
//Should only be called from the single global CDb pointer to ensure
//non-static data stored in the view handlers is processed correctly.
{
	RemoveEmptyRows();

	CDbBase::Commit();
}

//*****************************************************************************
void CDb::Rollback()
//Rolls back changes in all the databases.
{
	RemoveEmptyRows(); //ResetEmptyRowCount(); //unstable if metakit rollback doesn't work right

	CDbBase::Rollback();
}

//*****************************************************************************
UINT CDb::GetHoldID()
//Returns: the current hold ID.  If it is zero, try to find the first ID.
{
	if (!CDb::dwCurrentHoldID)
	{
		CDbHold *pHold = this->Holds.GetFirst(true);
		while (pHold)
		{
			const CDbHold::HoldStatus status = pHold->status;
			const UINT holdID = pHold->dwHoldID;
			delete pHold;

			//Skip tutorial holds
			if (status != CDbHold::Tutorial) {
				CDb::dwCurrentHoldID = holdID;
				pHold = NULL;
			} else {
				pHold = this->Holds.GetNext();
			}
		}
	}
	return CDb::dwCurrentHoldID;
}

//*****************************************************************************
UINT CDb::GetPlayerID()
//Returns: the current player ID.  If it is zero, try to find the first local ID.
{
	if (!CDb::dwCurrentPlayerID)
	{
		this->Players.FilterByLocal();
		CDbPlayer *pPlayer = this->Players.GetFirst(true);
		if (pPlayer)
		{
			if (g_pTheNet) g_pTheNet->ClearActiveAction();
			CDb::dwCurrentPlayerID = pPlayer->dwPlayerID;
		   if (g_pTheNet) g_pTheNet->DownloadHoldList();
			delete pPlayer;
		}
	}
	return CDb::dwCurrentPlayerID;
}

//*****************************************************************************
CDbPlayer* CDb::GetCurrentPlayer()
{
	return this->Players.GetByID(GetPlayerID());
}

CDbPackedVars CDb::GetCurrentPlayerSettings()
{
	return this->Players.GetSettings(GetPlayerID());
}

//*****************************************************************************
CCurrentGame* CDb::GetDummyCurrentGame()
//If something needs access to an empty CCurrentGame object.
{
	CCurrentGame *pCCG = new CCurrentGame();
	pCCG->bNoSaves = true;
	CCurrentGame::InitRPGStats(pCCG->pPlayer->st);
	pCCG->pPlayer->wAppearance = M_NONE; //not in room
	return pCCG;
}

//*****************************************************************************
CCurrentGame *CDb::GetSavedCurrentGame(
//Gets a current game object from a saved game.
//
//Params:
	const UINT dwSavedGameID, //(in)   Indicates saved game to load from.
	CCueEvents &CueEvents,     //(out)  Cue events generated by swordsman's first step 
								//    into the room.
	bool bRestoreAtRoomStart,  //(in)   If true, current game will be loaded to beginning
								//    of room in saved game.  If false, (default)
								//    current game will be loaded to the exact room
								//    state specified in the saved game.
	const bool bNoSaves) //whether DB saves should be prevented [default=false]
//
//Returns:
//Pointer to loaded current game which caller must delete, or NULL saved game did not exist
//or loading failures occurred.
{
	CCurrentGame *pCCG = new CCurrentGame();
	if (pCCG)
	{
		if (!pCCG->LoadFromSavedGame(dwSavedGameID, CueEvents, bRestoreAtRoomStart, bNoSaves))
		{
			delete pCCG;
			pCCG=NULL;
		}
	}
	return pCCG;
}

//*****************************************************************************
CCurrentGame *CDb::GetNewCurrentGame(
//Gets a current game object from a hold.  The current game will be set to the
//starting settings for the hold.
//
//Params:
	const UINT dwHoldID,      //(in) Indicates hold to load from.
	CCueEvents &CueEvents)     //(out)  Cue events generated by swordsman's
								//    first step  into the room.
//	const UINT dwAutoSaveOptions) //(in) game save options [default=ASO_DEFAULT]
//
//Returns:
//Pointer to loaded current game which caller must delete, or NULL if hold did
//not exist or loading failures occurred.
{
	CCurrentGame *pCCG = new CCurrentGame();
	if (pCCG)
	{
//		pCCG->SetAutoSaveOptions(dwAutoSaveOptions);
		if (!pCCG->LoadFromHold(dwHoldID, CueEvents))
		{
			delete pCCG;
			pCCG=NULL;
		}
	}
	return pCCG;
}

//*****************************************************************************
CCurrentGame *CDb::GetNewTestGame(
//Gets a current game object from a room.
//The current game will be set to the starting settings for the room.
//Used for testing.
//
//Params:
	const UINT dwRoomID,      //(in) Indicates room to load from.
	CCueEvents &CueEvents,     //(out)  Cue events generated by swordsman's
								//    first step into the room.
	const UINT wX, const UINT wY, const UINT wO, //(in) Starting position
	const PlayerStats& st, //(in) starting stats
	const bool bNoSaves) //whether DB saves should be prevented [default=false]
//
//Returns:
//Pointer to loaded current game which caller must delete, or NULL if room did
//not exist or loading failures occurred.
{
	CCurrentGame *pCCG = new CCurrentGame();
	if (pCCG)
	{
		pCCG->pPlayer->st = st;
		if (!pCCG->LoadFromRoom(dwRoomID, CueEvents, wX, wY, wO, defaultPlayerType(), false, bNoSaves))
		{
			delete pCCG;
			pCCG=NULL;
		}
	}
	return pCCG;
}

//*******************************************************************************
bool CDb::ValidateSavedGame(
//Validates a saved game for correctness (play sequence is still valid) and stats.
//
//Returns: whether saved game exists, is correct and valid
//
//Params:
	const UINT savedGameID,
	WSTRING& scoreCheckpointName, //(out) name of last score checkpoint encountered
	PlayerStats& ps) //(out) player stats when last checkpoint is encountered
{
	CDbSavedGame *pSavedGame = this->SavedGames.GetByID(savedGameID);
	if (!pSavedGame)
		return false; //doesn't exist
	CDbSavedGameMove *pSavedGameMoves = NULL;
	if (!pSavedGame->ExploredRooms.empty())
	{
		//If the player has been to other rooms, a move sequence must exist
		//in order to validate the entire saved game playthrough.
		pSavedGameMoves = this->SavedGameMoves.GetByID(savedGameID);
		if (!pSavedGameMoves) //doesn't exist -- can't validate
		{
			delete pSavedGame;
			return false;
		}
	} else {
		pSavedGameMoves = this->SavedGameMoves.GetNew();
	}

	//Include the moves in the current room as well.
	pSavedGameMoves->Append(pSavedGame->Commands, true); //mark end-of-sequence
	const CStretchyBuffer& moveSequence = pSavedGameMoves->getMoves();

	const UINT holdID = this->SavedGames.GetHoldIDofSavedGame(savedGameID);
	const bool bGood = ValidateMoveSequence(holdID, moveSequence, scoreCheckpointName, ps);

	delete pSavedGameMoves;
	delete pSavedGame;

	return bGood;
}

//*******************************************************************************
bool CDb::ValidateMoveSequence(
//Validates a saved game for correctness (play sequence is still valid) and stats.
//
//Returns: whether hold exists and move sequence is correct and valid
//
//Params:
	const UINT holdID,
	const CStretchyBuffer& moves, //full move sequence
	WSTRING& scoreCheckpointName, //(out) name of last score checkpoint encountered
	PlayerStats& ps) //(out) player stats when last checkpoint is encountered
{
	const UINT bufSize = moves.Size();

	//Start from the beginning of the game.
	CCueEvents CueEvents;
	CCurrentGame *pGame = GetNewCurrentGame(holdID, CueEvents);
	if (!pGame)
		return false; //can't start a game for whatever reason -- can't validate

	//playback only
	pGame->bNoSaves = pGame->bValidatingPlayback = true;
	pGame->FreezeCommands();

	//Play through all moves in the game session.
	bool bGood = true;
	UINT wX, wY;
	UINT index = 0;
	while (index < bufSize)
	{
		const UINT command = moves.GetUINTat(index); //get next command

		//Ensure no play-testing "cheat" commands are used in scoreable play-throughs.
		if (command == CMD_SETVAR)
		{
			bGood = false;
			break;
		}

		if (!ValidateMoveSequenceCheckCueEvents(CueEvents, pGame, command, bGood, scoreCheckpointName, ps))
			break;

		if (CueEvents.HasAnyOccurred(IDCOUNT(CIDA_PlayerLeftRoom), CIDA_PlayerLeftRoom))
		{
			//Load new level, if needed.
			if (CueEvents.HasOccurred(CID_ExitLevelPending))
			{
				const CCoord *pExitInfo =
						DYN_CAST(const CCoord*, const CAttachableObject*,
						CueEvents.GetFirstPrivateData(CID_ExitLevelPending));
				const UINT dwEntranceID = pExitInfo->wX;

				CueEvents.Clear();
				pGame->UnfreezeCommands(); //must be done before loading
				pGame->LoadFromLevelEntrance(holdID, dwEntranceID, CueEvents);
				pGame->FreezeCommands();
				//The "continue" below lets us validate these new cue events
				//before playing the next command.
			} else {
				CueEvents.Clear(); //we're done checking these events
			}

			continue; //advance to next command
		}

		//No end room marker should exist without room exit cue events.
		if (command == CMD_EXITROOM)
		{
			bGood = false; //validation failed
			break;
		}

		//If game is still not ready to process a play command at this point,
		//something bad happened on the last turn causing play to halt.
		if (!pGame->bIsGameActive)
		{
			bGood = false; //validation failed
			break;
		}

		if (command == CMD_ENDMOVE)
			break; //done validating

		//Now that we've checked for everything, execute the next command.

		//Complex command parameters.
		if (bIsComplexCommand(command))
		{
			wX = moves.GetUINTat(index);
			wY = moves.GetUINTat(index);
		} else {
			wX = wY = UINT(-1);
		}

		//Execute this command.
		pGame->ProcessCommand(command, CueEvents, wX, wY);
	}

	//Resolve any combat initiated on final move
	while (bGood && pGame->InCombat())
	{
		CueEvents.Clear();
		pGame->ProcessCommand(CMD_ADVANCE_COMBAT, CueEvents);
		if (!ValidateMoveSequenceCheckCueEvents(CueEvents, pGame, CMD_ADVANCE_COMBAT, bGood, scoreCheckpointName, ps))
			break;
	}

	delete pGame;

	return bGood;
}

//Returns: true if play continues, false if ended
bool CDb::ValidateMoveSequenceCheckCueEvents(
	CCueEvents& CueEvents, CCurrentGame* pGame, const UINT command,
	bool& bGood, WSTRING& scoreCheckpointName, PlayerStats& ps) //(out)
const
{
	const bool bPlayerDied = CueEvents.HasAnyOccurred(IDCOUNT(CIDA_PlayerDied), CIDA_PlayerDied);
	if (bPlayerDied)
	{
		bGood = false; //validation failed
		return false;
	}

	//Check for a score checkpoint.
	if (CueEvents.HasOccurred(CID_ScoreCheckpoint))
	{
		//Output name of score checkpoint and player stats at that checkpoint.
		const CDbMessageText *pScoreIDText = DYN_CAST(const CDbMessageText*, const CAttachableObject*,
			CueEvents.GetFirstPrivateData(CID_ScoreCheckpoint));
		ASSERT((const WCHAR*)(*pScoreIDText));
		scoreCheckpointName = (const WCHAR*)(*pScoreIDText);
		ps = pGame->pPlayer->st;

		//Alter stats to match how they are scored.
		ps.ATK = pGame->getPlayerATK();
		ps.DEF = pGame->getPlayerDEF();
	}

	//Was room exited?
	const bool bDidPlayerLeaveRoom = CueEvents.HasAnyOccurred(
		IDCOUNT(CIDA_PlayerLeftRoom), CIDA_PlayerLeftRoom);

	if (bDidPlayerLeaveRoom)
	{
		if (CueEvents.HasOccurred(CID_WinGame))
			return false; //count as valid play sequence to end of game (even if more play moves exist)
						  
		//Whenever the player leaves the room,
		//the current command should be an end room marker.
		if (command != CMD_EXITROOM)
		{
			bGood = false; //validation failed
			return false;
		}
	}

	return true;
}

//*****************************************************************************
UINT CDb::LookupRowByPrimaryKey(
//Looks up a row in a view by its primary key ID property.
//Assumes primary key property values are monotonically increasing.
//
//Params:
	const UINT dwID,    //(in) Primary key value to match.
	const VIEWTYPE eViewType,  //(in) View/table to scan
	c4_View &View)  //(out) specific view containing this ID
//
//Returns:
//Row index in the outputted view or ROW_NO_MATCH.
{
	//Determine prop for primary key based on table.
	c4_IntProp *pPropID = GetPrimaryKeyProp(eViewType);	//Reference to the primary key field.

	//Determine the rows available for search based on the count maintained
	//in the respective view interface of the global DB object.
	UINT dwRowCount;
	switch (eViewType)
	{
		case V_Data: dwRowCount = g_pTheDB->Data.GetViewSize(dwID); break;
		case V_Demos: dwRowCount = g_pTheDB->Demos.GetViewSize(dwID); break;
		case V_Holds: dwRowCount = g_pTheDB->Holds.GetViewSize(dwID); break;
		case V_Levels: dwRowCount = g_pTheDB->Levels.GetViewSize(dwID); break;
		case V_MessageTexts: dwRowCount = GetView(eViewType, dwID).GetSize(); break;
		case V_Players: dwRowCount = g_pTheDB->Players.GetViewSize(dwID); break;
		case V_Rooms: dwRowCount = g_pTheDB->Rooms.GetViewSize(dwID); break;
		case V_SavedGames: dwRowCount = g_pTheDB->SavedGames.GetViewSize(dwID); break;
		case V_SavedGameMoves: dwRowCount = g_pTheDB->SavedGameMoves.GetViewSize(dwID); break;
		case V_Speech: dwRowCount = g_pTheDB->Speech.GetViewSize(dwID); break;
		default:
			ASSERT(!"CDb::LookupRowByPrimaryKey: Unexpected property type.");
			return ROW_NO_MATCH;
	}

	return CDbBase::LookupRowByPrimaryKey(dwID, eViewType, pPropID, dwRowCount, View);
}

//*****************************************************************************
void CDb::ResetMembership()
//Reset all table memberships.
{
	this->Data.ResetMembership();
	this->Demos.ResetMembership();
	this->Holds.ResetMembership();
	this->Levels.ResetMembership();
	this->Players.ResetMembership();
	this->Rooms.ResetMembership();
	this->SavedGames.ResetMembership();
	this->Speech.ResetMembership();
}

//*****************************************************************************
void CDb::SetHoldID(const UINT dwNewHoldID)
//Set active hold ID.
{
	dwCurrentHoldID = dwNewHoldID;
	this->SavedGames.FilterByHold(dwNewHoldID);
}

//*****************************************************************************
void CDb::SetPlayerID(const UINT dwNewPlayerID, const bool bCaravelLogin) //[default=true]
//Set active player and filter saved games for them.
{
	if (CDb::dwCurrentPlayerID == dwNewPlayerID)
		return; //nothing to change

	//Resolve any transactions in progress before changing the player.
   if (g_pTheNet && bCaravelLogin)
		g_pTheNet->ClearActiveAction();

	CDb::dwCurrentPlayerID = dwNewPlayerID;

	//Get hold list according to settings for new player.
	if (g_pTheNet && bCaravelLogin)
		g_pTheNet->DownloadHoldList();

	this->SavedGames.FilterByPlayer(dwNewPlayerID);
}

//*****************************************************************************
//Acceleration structure -- indexed for fast hierarchical ID set lookup.
struct HoldOwnership {
	CIDSet levelIDs, dataIDs;
};
typedef map<UINT,HoldOwnership> holdMap;

typedef CIDSet LevelOwnership;
typedef map<UINT,LevelOwnership> levelMap;

struct RoomOwnership {
	CIDSet demoIDs, savedGameIDs;
};
typedef map<UINT,RoomOwnership> roomMap;

typedef map<UINT,UINT> idMap;

holdMap holdIndex; //hold -> levels + data
levelMap levelIndex; //level -> rooms
roomMap roomIndex; //room -> saved games + demos
idMap demoIndex; //demo -> saved game
idMap demosHoldIndex; //demo -> hold

//*****************************************************************************
void CDb::addDataToHold(const UINT dataID, const UINT holdID)
//Adds dataID to hold's data set.
{
	CDbBase::DirtyData();

	if (!holdID)
		return; //no hold to attach this data to

	holdMap::iterator holdIter = holdIndex.find(holdID);
	if (holdIter == holdIndex.end())
	{
		ASSERT(!"Data exists in DB with dangling hold ID");
	} else {
		//Add the datum to its parent hold's level ID set.
		holdIter->second.dataIDs += dataID;
	}
}

//*****************************************************************************
void CDb::addDemo(const UINT demoID, const UINT savedGameID)
//Adds demo to index.
{
	CDbBase::DirtySave();
	ASSERT(demoIndex.find(demoID) == demoIndex.end());
	ASSERT(demosHoldIndex.find(demoID) == demosHoldIndex.end());
	ASSERT(savedGameID); //each demo must be attached to a saved game
	if (!savedGameID)
		return; //robust to bad data

	//Link demo to its saved game, room and hold.
	demoIndex[demoID] = savedGameID;

	const UINT demosRoomID = CDbSavedGames::GetRoomIDofSavedGame(savedGameID);
	ASSERT(demosRoomID);
	const UINT demosHoldID = CDbRooms::GetHoldIDForRoom(demosRoomID);
	ASSERT(demosHoldID);
	roomMap::iterator room = roomIndex.find(demosRoomID);
	ASSERT(room != roomIndex.end());
	room->second.demoIDs += demoID;

	demosHoldIndex[demoID] = demosHoldID;
}

//*****************************************************************************
void CDb::addHold(const UINT holdID)
//Adds hold to index.
{
	CDbBase::DirtyHold();
	ASSERT(holdIndex.find(holdID) == holdIndex.end());

	HoldOwnership IDs;
	holdIndex[holdID] = IDs;
}

//*****************************************************************************
void CDb::addLevelToHold(const UINT levelID, const UINT holdID)
//Adds level to index.
{
	CDbBase::DirtyHold();
	ASSERT(levelIndex.find(levelID) == levelIndex.end());

	LevelOwnership IDs;
	levelIndex[levelID] = IDs;
	//Add level to hold.
	holdMap::iterator hold = holdIndex.find(holdID);
	ASSERT(hold != holdIndex.end());
	hold->second.levelIDs += levelID;
}

//*****************************************************************************
void CDb::addRoomToLevel(const UINT roomID, const UINT levelID)
//Adds room to index.
{
	CDbBase::DirtyHold();
	ASSERT(roomIndex.find(roomID) == roomIndex.end());

	RoomOwnership roomIDs;
	roomIndex[roomID] = roomIDs;
	//Add room to level.
	levelMap::iterator level = levelIndex.find(levelID);
	ASSERT(level != levelIndex.end());
	level->second += roomID;
}

//*****************************************************************************
void CDb::addSavedGameToRoom(const UINT savedGameID, const UINT roomID)
//Adds saved game to index.
{
	CDbBase::DirtySave();
	if (roomID) //some special saved game records are not associated with a room
	{
		roomMap::iterator room = roomIndex.find(roomID);
		ASSERT(room != roomIndex.end());
		room->second.savedGameIDs += savedGameID;
	}
}

//*****************************************************************************
void CDb::deleteData(const UINT dataID)
//Remove data ID from any hold that owns it.
{
	CDbBase::DirtyData();
	for (holdMap::iterator hold = holdIndex.begin(); hold != holdIndex.end(); ++hold)
		hold->second.dataIDs -= dataID;
}

//*****************************************************************************
void CDb::deleteDemo(const UINT demoID)
//Remove demo from hold and room.
{
	CDbBase::DirtySave();

	//Find demo's room to remove demoID from room index.
	const UINT savedGameID = getSavedGameOfDemo(demoID);
	const UINT roomID = CDbSavedGames::GetRoomIDofSavedGame(savedGameID);
	roomMap::iterator room = roomIndex.find(roomID);
	if (room != roomIndex.end())
		room->second.demoIDs -= demoID;

	//Now remove demo mappings.
	demoIndex.erase(demoID);
	demosHoldIndex.erase(demoID);
}

//*****************************************************************************
void CDb::deleteHold(const UINT holdID)
//Remove hold from index.
{
	CDbBase::DirtyHold();
	holdMap::iterator holdIter = holdIndex.find(holdID);
	if (holdIter != holdIndex.end())
		holdIndex.erase(holdIter);
}

//*****************************************************************************
void CDb::deleteLevel(const UINT levelID)
//Remove level from index.
{
	CDbBase::DirtyHold();
	levelMap::iterator levelIter = levelIndex.find(levelID);
	if (levelIter != levelIndex.end())
	{
		levelIndex.erase(levelIter);
		//Delete level from hold that owns it.
		const UINT holdID = CDbLevels::GetHoldIDForLevel(levelID);
		if (holdID)
		{
			holdMap::iterator hold = holdIndex.find(holdID);
			ASSERT(hold != holdIndex.end());
			hold->second.levelIDs -= levelID;
		}
	}
}

//*****************************************************************************
void CDb::deleteRoom(const UINT roomID)
//Remove room from index.
{
	CDbBase::DirtyHold();
	roomMap::iterator roomIter = roomIndex.find(roomID);
	if (roomIter != roomIndex.end())
	{
		roomIndex.erase(roomIter);
		//Delete room from level that owns it.
		const UINT levelID = CDbRooms::GetLevelIDForRoom(roomID);
		if (levelID)
		{
			levelMap::iterator level = levelIndex.find(levelID);
			ASSERT(level != levelIndex.end());
			level->second -= roomID;
		}
	}
}

//*****************************************************************************
void CDb::deleteSavedGame(const UINT savedGameID)
//Remove saved game from room.
{
	CDbBase::DirtySave();

	//Find saved game's room to remove savedGameID from room index.
	const UINT roomID = CDbSavedGames::GetRoomIDofSavedGame(savedGameID);
	roomMap::iterator room = roomIndex.find(roomID);
	if (room != roomIndex.end())
		room->second.savedGameIDs -= savedGameID;
}

//*****************************************************************************
CIDSet CDb::getDataInHold(const UINT holdID)
//Returns: set of dataIDs belonging to this hold, or empty set if hold doesn't exist
{
	holdMap::iterator holdIter = holdIndex.find(holdID);
	if (holdIter == holdIndex.end())
		return CIDSet(); //no entry
	return holdIter->second.dataIDs;
}

//*****************************************************************************
CIDSet CDb::getDemosInHold(const UINT holdID)
//Returns: set of demos in hold
{
	CIDSet demosInHold, levelsInHold = CDb::getLevelsInHold(holdID);
	for (CIDSet::const_iterator level = levelsInHold.begin();
			level != levelsInHold.end(); ++level)
		demosInHold += CDb::getDemosInLevel(*level);
	return demosInHold;
}

//*****************************************************************************
CIDSet CDb::getDemosInLevel(const UINT levelID)
//Returns: set of demos in level
{
	CIDSet demosInLevel, roomsInLevel = CDb::getRoomsInLevel(levelID);
	for (CIDSet::const_iterator room = roomsInLevel.begin();
			room != roomsInLevel.end(); ++room)
		demosInLevel += CDb::getDemosInRoom(*room);
	return demosInLevel;
}

//*****************************************************************************
CIDSet CDb::getDemosInRoom(const UINT roomID)
//Returns: set of demos in room
{
	roomMap::iterator roomIter = roomIndex.find(roomID);
	if (roomIter == roomIndex.end())
		return CIDSet(); //no entry
	return roomIter->second.demoIDs;
}

//*****************************************************************************
UINT CDb::getHoldOfDemo(const UINT demoID)
//Returns: holdID of the hold that this demo is in
{
	idMap::iterator demoIter = demosHoldIndex.find(demoID);
	return demoIter != demosHoldIndex.end() ? demoIter->second : 0;
}

//*****************************************************************************
CIDSet CDb::getLevelsInHold(const UINT holdID)
//Returns: set of levelIDs belonging to this hold, or empty set if hold doesn't exist
{
	holdMap::iterator holdIter = holdIndex.find(holdID);
	if (holdIter == holdIndex.end())
		return CIDSet(); //no entry
	return holdIter->second.levelIDs;
}

//*****************************************************************************
CIDSet CDb::getRoomsInHold(const UINT holdID)
//Returns: set of roomIDs belonging to this hold, or empty set if level doesn't exist
{
	CIDSet roomsInHold;
	const CIDSet levelsInHold = CDb::getLevelsInHold(holdID);
	for (CIDSet::const_iterator iter = levelsInHold.begin(); iter != levelsInHold.end(); ++iter)
		roomsInHold += CDb::getRoomsInLevel(*iter);
	return roomsInHold;
}

//*****************************************************************************
CIDSet CDb::getRoomsInLevel(const UINT levelID)
//Returns: set of roomIDs belonging to this level, or empty set if level doesn't exist
{
	levelMap::iterator levelIter = levelIndex.find(levelID);
	if (levelIter == levelIndex.end())
		return CIDSet(); //no entry
	return levelIter->second;
}

//*****************************************************************************
UINT CDb::getSavedGameOfDemo(const UINT demoID)
//Returns: savedGameID that this demo is tied to
{
	idMap::iterator demoIter = demoIndex.find(demoID);
	return demoIter != demoIndex.end() ? demoIter->second : 0;
}

//*****************************************************************************
CIDSet CDb::getSavedGamesInHold(const UINT holdID)
{
	CIDSet savedGamesInHold, levelsInHold = CDb::getLevelsInHold(holdID);
	for (CIDSet::const_iterator level = levelsInHold.begin();
			level != levelsInHold.end(); ++level)
		savedGamesInHold += CDb::getSavedGamesInLevel(*level);
	return savedGamesInHold;
}

//*****************************************************************************
CIDSet CDb::getSavedGamesInLevel(const UINT levelID)
{
	CIDSet savedGamesInLevel, roomsInLevel = CDb::getRoomsInLevel(levelID);
	for (CIDSet::const_iterator room = roomsInLevel.begin();
			room != roomsInLevel.end(); ++room)
		savedGamesInLevel += getSavedGamesInRoom(*room);
	return savedGamesInLevel;
}

//*****************************************************************************
CIDSet CDb::getSavedGamesInRoom(const UINT roomID)
//Returns: set of saved games in room
{
	roomMap::iterator roomIter = roomIndex.find(roomID);
	if (roomIter == roomIndex.end())
		return CIDSet(); //no entry
	return roomIter->second.savedGameIDs;
}

//*****************************************************************************
bool CDb::holdExists(const UINT holdID)
{
	holdMap::iterator holdIter = holdIndex.find(holdID);
	return holdIter != holdIndex.end();
}

//*****************************************************************************
bool CDb::levelExists(const UINT levelID)
{
	levelMap::iterator levelIter = levelIndex.find(levelID);
	return levelIter != levelIndex.end();
}

//*****************************************************************************
void CDb::moveData(const UINT dataID, const UINT fromHoldID, const UINT toHoldID)
//Updates data-hold indexing when data object might have changed holds.
{
	CDbBase::DirtyData();
	if (fromHoldID == toHoldID)
		return; //data object is in the same hold as before

	//Remove data index from previous hold.
	holdMap::iterator hold;
	if (fromHoldID)
	{
		hold = holdIndex.find(fromHoldID);
		ASSERT(hold != holdIndex.end());
		hold->second.dataIDs -= dataID;
	}

	//Add data index to current hold.
	if (toHoldID)
	{
		hold = holdIndex.find(toHoldID);
		ASSERT(hold != holdIndex.end());
		hold->second.dataIDs += dataID;
	}
}

//*****************************************************************************
void CDb::moveRoom(const UINT roomID, const UINT fromLevelID, const UINT toLevelID)
//Updates room-level indexing when room might have changed levels.
{
	CDbBase::DirtyHold();
	if (fromLevelID == toLevelID)
		return; //room is in the same level as before

	//Remove room index from previous level.
	levelMap::iterator level = levelIndex.find(fromLevelID);
	ASSERT(level != levelIndex.end());
	level->second -= roomID;

	//Add room index to current level.
	level = levelIndex.find(toLevelID);
	ASSERT(level != levelIndex.end());
	level->second += roomID;
}

//*****************************************************************************
void CDb::moveSavedGame(const UINT savedGameID, const UINT fromRoomID, const UINT toRoomID)
//Updates savedgame-room indexing when room might have changed levels.
{
	CDbBase::DirtySave();
	if (fromRoomID == toRoomID)
		return; //saved game is in the same room as before

	//Remove savedgame index from previous room.
	if (fromRoomID) //some special saved game records are not associated with a room
	{
		roomMap::iterator room = roomIndex.find(fromRoomID);
		ASSERT(room != roomIndex.end());
		room->second.savedGameIDs -= savedGameID;
	}

	//Add saved game index to current room.
	if (toRoomID)
	{
		roomMap::iterator room = roomIndex.find(toRoomID);
		ASSERT(room != roomIndex.end());
		room->second.savedGameIDs += savedGameID;
	}
}

//*****************************************************************************
void CDb::resetIndex()
//Resets database ID hierarchy.
{
	holdIndex.clear();
	levelIndex.clear();
	roomIndex.clear();
	demoIndex.clear();
	demosHoldIndex.clear();

	CDbBase::resetIndex();
}

//*****************************************************************************
void CDb::buildIndex()
//Constructs map of database ID hierarchy.
//Currently, this includes holds, levels, rooms, and saved games + demos.
{
	ASSERT(holdIndex.empty()); //This method should only be called once.

	//Build hold index.
	//Scan rows of holds DB table directly for speed.
	const UINT holdCount = GetViewSize(V_Holds);
	for (UINT holdI = 0; holdI < holdCount; ++holdI)
	{
		c4_RowRef row = GetRowRef(V_Holds, holdI);
		addHold(UINT(p_HoldID(row)));
	}

	//Build data index.
	const UINT dataCount = GetViewSize(V_Data);
	for (UINT dataI = 0; dataI < dataCount; ++dataI)
	{
		c4_RowRef row = GetRowRef(V_Data, dataI);
		const UINT dataID = UINT(p_DataID(row));

		//Look up this level's hold in the hold map.
		const UINT datumsHoldID = UINT(p_HoldID(row));
		if (datumsHoldID) //ignore data not belonging to any hold
			addDataToHold(dataID, datumsHoldID);
	}

	//Build level index.
	const UINT levelCount = GetViewSize(V_Levels);
	for (UINT levelI = 0; levelI < levelCount; ++levelI)
	{
		c4_RowRef row = GetRowRef(V_Levels, levelI);
		const UINT levelID = UINT(p_LevelID(row));

		//Add level entry.
		LevelOwnership IDs;
		levelIndex[levelID] = IDs;

		//Look up this level's hold in the hold map.
		const UINT levelsHoldID = UINT(p_HoldID(row));
		holdMap::iterator holdIter = holdIndex.find(levelsHoldID);
		if (holdIter == holdIndex.end())
		{
			ASSERT(!"Level exists in DB without a hold");
		} else {
			//Add the level to its parent hold's level ID set.
			HoldOwnership& holdIndex = holdIter->second;
			holdIndex.levelIDs += levelID;
		}
	}

	//Build room index.
	const UINT roomCount = GetViewSize(V_Rooms);
	for (UINT roomI = 0; roomI < roomCount; ++roomI)
	{
		c4_RowRef row = GetRowRef(V_Rooms, roomI);
		const UINT roomID = UINT(p_RoomID(row));

		//Add room entry.
		RoomOwnership IDs;
		roomIndex[roomID] = IDs;

		//Look up this room's level in the level map.
		const UINT roomsLevelID = UINT(p_LevelID(row));
		levelMap::iterator levelIter = levelIndex.find(roomsLevelID);
		if (levelIter == levelIndex.end())
		{
			ASSERT(!"Room exists in DB without a level");
		} else {
			//Add the room to its parent level's room ID set.
			levelIter->second += roomID;
		}
	}

	//Build demo index.
	idMap savedGameDemoIndex; //for building set of demos in a room below
	const UINT demoCount = GetViewSize(V_Demos);
	for (UINT demoI = 0; demoI < demoCount; ++demoI)
	{
		c4_RowRef row = GetRowRef(V_Demos, demoI);
		const UINT demosSavedGameID = UINT(p_SavedGameID(row));
		const UINT savedGamesDemoID = UINT(p_DemoID(row));
		demoIndex[savedGamesDemoID] = demosSavedGameID;
		savedGameDemoIndex[demosSavedGameID] = savedGamesDemoID;
	}

	//Build saved game index.
	idMap::iterator iter;
	const UINT savedGameCount = GetViewSize(V_SavedGames);
	for (UINT sgI = 0; sgI < savedGameCount; ++sgI)
	{
		c4_RowRef row = GetRowRef(V_SavedGames, sgI);
		const UINT savedGamesRoomID = UINT(p_RoomID(row));
		roomMap::iterator roomIter = roomIndex.find(savedGamesRoomID);
		if (roomIter != roomIndex.end()) //some special saved game types aren't associated with a room
		{
			//Add the saved game to its parent room's saved game ID set.
			RoomOwnership& roomIndex = roomIter->second;
			const UINT savedGameID = UINT(p_SavedGameID(row));
			roomIndex.savedGameIDs += savedGameID;
			//If a demo owns this saved game, track this.
			iter = savedGameDemoIndex.find(savedGameID);
			if (iter != savedGameDemoIndex.end())
			{
				const UINT demoID = iter->second;
				roomIndex.demoIDs += demoID;
				//Track which hold this demo is in.
				const UINT demosHoldID = CDbRooms::GetHoldIDForRoom(savedGamesRoomID);
				demosHoldIndex[demoID] = demosHoldID;
			}
		}
	}

	CDbBase::buildIndex();
}

//
// Private methods
//

//*****************************************************************************
bool CDb::EmptyRowsExist() const
{
	if (this->Data.emptyEndRows) return true;
	if (this->Demos.emptyEndRows) return true;
	if (this->Holds.emptyEndRows) return true;
	if (this->Levels.emptyEndRows) return true;
	if (this->Players.emptyEndRows) return true;
	if (this->Rooms.emptyEndRows) return true;
	if (this->SavedGames.emptyEndRows) return true;
	if (this->Speech.emptyEndRows) return true;

	return false;
}

//*****************************************************************************
void CDb::ResetEmptyRowCount()
//When rolling back the DB, empty row counts should be reset.
{
	this->Data.emptyEndRows = 0;
	this->Demos.emptyEndRows = 0;
	this->Holds.emptyEndRows = 0;
	this->Levels.emptyEndRows = 0;
	this->Players.emptyEndRows = 0;
	this->Rooms.emptyEndRows = 0;
	this->SavedGames.emptyEndRows = 0;
	this->Speech.emptyEndRows = 0;
}

//*****************************************************************************
void CDb::RemoveEmptyRows()
//Removes any unused, empty rows added previously to the end of each view.
{
	if (this->Data.emptyEndRows)
	{
		this->Data.RemoveEmptyRows();
		DirtyData();
	}
	if (this->Demos.emptyEndRows || this->SavedGames.emptyEndRows)
	{
		this->Demos.RemoveEmptyRows();
		this->SavedGames.RemoveEmptyRows();
		DirtySave();
	}
	if (this->Holds.emptyEndRows || this->Levels.emptyEndRows ||
			this->Rooms.emptyEndRows || this->Speech.emptyEndRows)
	{
		this->Holds.RemoveEmptyRows();
		this->Levels.RemoveEmptyRows();
		this->Rooms.RemoveEmptyRows();
		this->Speech.RemoveEmptyRows();
		DirtyHold();
	}
	if (this->Players.emptyEndRows)
	{
		this->Players.RemoveEmptyRows();
		DirtyPlayer();
	}
	//no extra rows need removing from text DB
}

